## 算法引入


> 动态规划（英语：Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。  
> 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。   
> 动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。   
> 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。

### 斐波那契数列

定义为：由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。

#### 1.暴力递归

依然可以运用动态规划的思想，我们可以得到状态转移方程 ：
$$
f(n)=f(n-1)+f(n-2)
$$
代码实现就出来了：

```python
def fib(n):
    # 边界条件（base case）
    if n in (1,2):
        return 1
    return fib(n-1) + fib(n-2)

```

这样暴力递归其实是效率很低的，画出递归树就可以很明显的看到：

<img src="https://gitee.com/fadeaway_dai/picgo_images/raw/master/img/image-20210318203531621.png" alt="image-20210318203531621" style="zoom: 67%;" />



计算f(20)的时候，计算出了f(19)和f(18)，到了计算f(19)的时候，又把f(18)计算了一遍，这样重复计算导致效率变低。

#### 2.备忘录优化

使用一个数组或者字典，将已经计算过的值存进去，就像一个缓存一样，这样就可以减少重复计算。

代码实现如下：

```python
def fib(n, tb: List):
    # 边界条件（base case）
    if n in (1,2):
        return 1
    if tb[n-1] is None:
    	tb[n-1] = fib(n-1, tb) + fib(n-2, tb)
    return tb[n-1]
```

递归图如下：

<img src="https://gitee.com/fadeaway_dai/picgo_images/raw/master/img/image-20210318203629965.png" alt="image-20210318203629965" style="zoom:67%;" />

这样就将递归树中的冗余计算都去掉了，时间复杂度从`O(n^2)`优化到了`O(n)`，可以说是降维打击。

根据思考解题的方向可知，这是一种自顶向下的方式，从最终结果也就是递归树的根节点，递归往下计算直至返回，如下图所示：

<img src="https://gitee.com/fadeaway_dai/picgo_images/raw/master/img/image-20210318203736050.png" alt="image-20210318203736050" style="zoom:67%;" />

#### 3.dp数组自底向上迭代

<img src="https://gitee.com/fadeaway_dai/picgo_images/raw/master/img/image-20210318204603563.png" alt="image-20210318204603563" style="zoom:67%;" />

其实我们还可以自底向上的迭代求解，从最小的f(1)和f(2)往上推出f(20)，代码实现如下：

```python
def fib(n):
    if n in (1,2):
        return 1
    dp = [0] * (n+1)
    dp[1]=dp[2]=1
    for i in range(3, n+1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]
```

#### 4.dp数组空间优化

我们观察到，每一次的结果实际只跟前两次的结果有关，所以可以只存储前两次的结果，对空间进行简化。

```python
def fib(n):
    if n in (1,2):
        return 1
    dp_1 = dp_2 =1
    for i in range(3, n+1):
        dp_1,dp_2=dp_1+dp_2,dp_1
    return dp_1
```

### 凑零钱问题

先看下题⽬：给你 k 种⾯值的硬币，⾯值分别为 c1, c2 ... ck ，每种硬 币的数量⽆限，再给⼀个总⾦额 amount ，问你**最少**需要⼏枚硬币凑出这个⾦额，如果不可能凑出，算法返回 -1 。

#### 自顶向下思考

思考步骤：

1. 此问题包含**最优子结构**的特点，并且子问题之间相互独立，所以是动态规划的问题。

2. 定义正确的dp函数，`dp(amount)=n`表示最少需要n个硬币凑出amount金额的钱，这个式子其实也很好列出来，题干中只有amount这一个变量，我们要求解的就是最少的硬币数，设为n，这样就很容易定义出dp函数了。

3. 列出状态转移方程：
   $$
   dp(amount)=min(dp(amount-c1)+1, dp(amount-c2)+1, ...)
   $$
   
4. 注意边界条件，如果不能凑出的情况就是当amount比其中最小的硬币面额还要小并且不为0。



代码实现如下：

```python
from typing import List


def min_coin_num(coins: List, amount: int):
    def dp(n):
        # 边界条件
        if n == 0:  # 金额为0，不需要硬币了
            return 0
        if n < 0:  # 金额为负了，当前递归子节点无解
            return -1
        ret = float("inf")
        for coin in coins:
            sub_problem = dp(n - coin)
            if sub_problem == -1:
                continue
            ret = min(ret, sub_problem + 1)
        return ret if ret != float("inf") else -1

    return dp(amount)
```

画出递归树后可以看到，依然存在冗余的计算，我们可以对此稍作优化，用一个备忘录记录已经计算过的结果，下次用到时，就不需要重复计算了。

<img src="https://gitee.com/fadeaway_dai/picgo_images/raw/master/img/image-20210319113207145.png" alt="image-20210319113207145" style="zoom:67%;" />

   优化后的代码：

```python
from typing import List


# 备忘录优化
def min_coin_num(coins: List, amount: int):
    memo = [None] * (amount + 1)

    def dp(n):
        if memo[n] is not None:
            return memo[n]

        # 边界条件
        if n == 0:  # 金额为0，不需要硬币了
            return 0
        if n < 0:  # 金额为负了，当前递归子节点无解
            return -1
        ret = float("inf")
        for coin in coins:
            sub_problem = dp(n - coin)
            if sub_problem == -1:
                continue
            ret = min(ret, sub_problem + 1)
        # 记入备忘录
        memo[n] = ret if ret != float("inf") else -1
        return memo[n]

    return dp(amount)
```

这里是用数组当备忘录，实际用字典也是一样。

#### 自底向上思考

一般自顶向下需要用到递归，思路是将最终的问题递归分解为一个一个的子问题，同样我们也可以自底向上计算出结果，从最初的情况向上经历有限次的迭代，最终得到结果。













方法总结：使用状态转移方程，描述中间状态之间的关系，即描述前一个小结果和后一个小结果之间的关系，依据这个关系链依次推导，可以得到最终结果。

适用情形：中间状态（结果）依赖于前一次的状态（结果）

## [三角形最小路径和](https://leetcode-cn.com/problems/triangle/)



![三角形最小路径和题干](https://raw.githubusercontent.com/fadeawaylove/article-images/master/三角形最小路径和.png)

![三角形最小路径和题干](https://raw.githubusercontent.com/fadeawaylove/article-images/master/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.png)

### 方法1：动态规划
解题思路：
> 使用动态规划关键还是找到状态转移方程，用$f(i,j)$表示三角形中第i行第j列元素的最短路径和，则可以得到状态转移方程：  
> $$
>f(i,j)=min(f(i-1, j), f(i-1, j-1)) + triangle[i][j]
>$$
> 意思就是：$当前元素的最短路径和=相邻上层元素的最短路径中的较小值+当前位置元素的值$
>（注意边界条件：元素为当前层第一个或者最后一个的时候，相邻的上层元素可以唯一确定）

代码如下：

```python
from typing import List


class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)  # 数组的长度（三角形的高度）
        f = [[0] * n for _ in range(n)]  # 保存每一层的结果，到当前层当前元素的最小路径
        f[0][0] = triangle[0][0]  # 第一层，第一个元素的结果就是三角形顶的值

        # 遍历获取每一层的结果
        for i in range(1, n):
            # 当前是第i行，从第二行（i=1表示第二行）开始
            # 这是边界条件，每一行的第一个元素只能由上一行的第一个元素获得
            f[i][0] = f[i - 1][0] + triangle[i][0]
            for j in range(1, i):
                # 第(i,j)个元素的结果，等于(i-1,j-1)和(i-1, j)中的较小值 加上 (i,j)处原本的值
                f[i][j] = min(f[i - 1][j], f[i - 1][j - 1]) + triangle[i][j]
            # 这是边界条件，每一行的第最后一个元素只能由上一行的最后一个元素获得
            f[i][i] = f[i - 1][i - 1] + triangle[i][i]
        return min(f[n - 1])


print(Solution().minimumTotal([
    [2],
    [3, 4],
    [6, 5, 7],
    [4, 1, 8, 3]
]))

```

### 方法2：动态规划+空间优化
解题思路：
> 方法1中我们使用了大小为$n*n$的矩阵来保存状态，是否可以使用更少的空间呢？用大小为$n$一维数组可以吗？
> 答案是可以的。   
> 如果每一层求解的时候从后往前计算，是不是就可以呢？考虑每一行最后一个元素的动态转移方程：$f(i,j)=min(f(i-1,j-1))+triangle[i][j]$，
>可以看到此时往保存状态的数组中第$j$个元素写入状态并不会改变之前已经得到的结果，因为此时状态数组中只有下标[0,j-1]的位置被占用了。


代码实现：
```python
from typing import List


class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)  # 数组的长度（三角形的高度）
        f = [0] * n  # 保存每一层的结果，到当前层当前元素的最小路径
        f[0] = triangle[0][0]  # 第一层，第一个元素的结果就是三角形顶的值

        # 遍历获取每一层的结果
        for i in range(1, n):
            f[i] = f[i-1] + triangle[i][i]  # 边界条件，f[i]是最后一个元素
            for j in range(i-1, 0, -1):
                # 第(i,j)个元素的结果，等于(i-1,j-1)和(i-1, j)中的较小值 加上 (i,j)处原本的值
                f[j] = min(f[j-1], f[j]) + triangle[i][j]
            # 这是边界条件，每一行的第最后一个元素只能由上一行的最后一个元素获得
            f[0] = f[0] + triangle[i][0]
        return min(f)


print(Solution().minimumTotal([
    [2],
    [3, 4],
    [6, 5, 7],
    [4, 1, 8, 3]
]))
```

## [计算各个位数不同的数字个数](https://leetcode-cn.com/problems/count-numbers-with-unique-digits/)

![](https://raw.githubusercontent.com/fadeawaylove/article-images/master/%E8%AE%A1%E7%AE%97%E5%90%84%E4%B8%AA%E4%BD%8D%E6%95%B0%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E5%AD%97%E4%B8%AA%E6%95%B0.png)

解题思路:
> 可以依次写出前几个的结果,看是否能得出转移方程:  
> $dp[0]=1$         
> $dp[1]=dp[0]+9$       
> $dp[2]=dp[1]+9*9$     
> $dp[3]=dp[2]+9*9*8$   
> 根据上面的式子,可以归纳出动态转移方程:
> $$
> \tag{n>=2}
> dp[n]=dp[n-1]+9*\prod_{i=0}^{n-2} {9-i}
> $$
> 当然要注意n的取值范围.

代码实现:
```python
class Solution:
    def countNumbersWithUniqueDigits(self, n: int) -> int:
        dp = [0] * (n + 1)
        dp[0] = 1
        for i in range(1, n + 1):
            temp = 9
            for m in range(i - 1):
                temp *= 9 - m
            dp[i] = dp[i - 1] + temp
        return dp[-1]


print(Solution().countNumbersWithUniqueDigits(3))

```



## [整数拆分](https://leetcode-cn.com/problems/integer-break/)



![1600937575567](https://raw.githubusercontent.com/fadeawaylove/article-images/master/1600937575567.png)

### 方法1：动态规划

解题思路：

> 设$dp[i]$为将正整数$i$拆分为至少两个正整数的和时的最大乘积，那么我们可以得到状态转移方程：
>
> $dp[i]=max(dp[i-j] \times j, (i-j) \times j)$，$(0<j<i)$
>
> 方程的含义就是，要求解$i$的最大乘积，可以将$i$拆分成两部分$j$和$i-j$,那么此时$dp[i]$就是$dp[i-j]\times j$和$(i-j)*j$中的较大值，其中$j$的取值范围为$(0,i)$

代码实现：

```python
class Solution:
    def integerBreak(self, n: int) -> int:
        dp = [0] * (n+1)
        for i in range(2, n+1):
            for j in range(1,i):
                dp[i] = max(dp[i],dp[i-j]*j, j*(i-j))
        return dp[-1]
```



### 方法2：动态规划优化

解题思路:

>方法1中$j$的范围为$(0,i)$,有没有办法缩小$j$的范围吗?
>
>我们知道,等分的时候乘积会是最大的,假设$n=a\times x$,$a$是分成的份数,那么我们要求的$y=x^{\frac n x}$的最大值,其实就是求$y=x^{\frac 1 x}$的最大值,根据数学的求导可以得出此时$x$应该为$e$($e\approx 2.7$),因为$x$为正整数,所以$x$可以为2或者3,落实到优化,$j$的取值范围可以只考虑2和3的情况.

代码实现:

```python
class Solution:
    def integerBreak(self, n: int) -> int:
        if n < 4:
            return n-1

        dp = [0] * (n+1)
        dp[2] = 1
        for i in range(2, n+1):
            dp[i] = max(dp[i-2]*2, 2*(i-2),dp[i-3]*3,3*(i-3))
        return dp[-1]
```



## [一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

![](https://raw.githubusercontent.com/fadeawaylove/article-images/master/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200925143210.png)

解题思路:

> 设$dp[i][j]$为$i$个0和$j$个1能拼出存在于数组$s$中的最大数量,我们可以得到动态转移方程:
> $$
> dp[i][j]=max(1+dp[i-cost\_zeros(k)][j-cost\_ones(k)])
> $$
> 其中$i>=cost\_zeros(k),j>cost\_ones(k)$
>
> 这个方程要表达的意思就是,假定当前字符串为k,如果能从k到$dp[i][j]$,那么$dp[i][j]$就等于k处最大数量加1,





![](https://raw.githubusercontent.com/fadeawaylove/article-images/master/%E4%B8%80%E5%92%8C%E9%9B%B6%E6%96%B9%E6%B3%951.gif)



代码实现:

```python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        dp = [[0]*(n+1) for _ in range(m+1)]
        for s in strs:
            zeros = s.count("0")
            ones = s.count("1")
            for i in range(m, zeros-1, -1):
                for j in range(n, ones-1, -1):
                    dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones] + 1)
        return dp[m][n]
```



## [K 站中转内最便宜的航班](https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/)

![1601022164584](https://raw.githubusercontent.com/fadeawaylove/article-images/master/1601022164584.png)

解题思路:

> 设$dp[k][d]$为经过$k$次转机到达目的地$d$的最最少费用,那么动态转移方程为:
> $$
> dp[k][d]=min(dp[k][d], dp[k-1][s]+p)
> $$
> 其中$s$为出发地,$p$为$s$到$d$的距离,也就是说当前$dp[k][d]$等于前一次$dp[k-1][s]+p$中的最小的一个

代码实现:

```python
class Solution(object):
    def findCheapestPrice(self, n, flights, src, dst, K):
        # 使用一个2*n的矩阵是为了优化空间,不然也可以使用k*n
        dp = [[float('inf')] * n for i in range(2)]
        # 初始化当前src和前提个src的值,都为0
        dp[0][src] = dp[1][src] = 0

        for k in range(K + 1):
            for s, d, p in flights:
                # 因为只有src是有值的,所以最开始只有当s=src的时候,d的值才会更新
                dp[k&1][d] = min(dp[k&1][d], dp[~k&1][s] + p)
        return dp[K&1][dst] if dp[K&1][dst] < float('inf') else -1
```



## [矩阵区域和](https://leetcode-cn.com/problems/matrix-block-sum/)

![](https://raw.githubusercontent.com/fadeawaylove/article-images/master/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200927120528.png)

### 方法1:动态规划

代码实现:

```python
from typing import List


class Solution:
    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:
        m = len(mat)  # 行
        n = len(mat[0])  # 列
        answer = [[0] * n for _ in range(m)]
        for j in range(n):
            jrange = (max(0, j - K), min(m, j + K + 1))
            for i in range(m):
                if i == 0:
                    for x in mat[0: min(K + 1, m)]:
                        answer[0][j] += sum(x[jrange[0]: jrange[1]])
                else:
                    irange = (max(0, i - K), min(m, i + K + 1))
                    add_item = 0 if i + K + 1 > m else sum(mat[i + K][jrange[0]: jrange[1]])
                    minus_item = 0 if i - K <= 0 else sum(mat[irange[0] - 1][jrange[0]:jrange[1]])
                    answer[i][j] = answer[i - 1][j] + add_item - minus_item
        return answer


print(Solution().matrixBlockSum([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1))
```



### 方法2:二维前缀和

代码实现:

```python
from typing import List

"""
使用前缀和
"""


class Solution:
    def matrixBlockSum(self, mat: List[List[int]], K: int) -> List[List[int]]:
        m = len(mat)  # 行
        n = len(mat[0])  # 列
        answer = [[0] * (n + 1) for _ in range(m + 1)]

        # 求出前缀和
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                answer[i][j] = answer[i][j - 1] + answer[i - 1][j] - answer[i - 1][j - 1] + mat[i - 1][j - 1]

        def get(x, y):
            # 处理边界问题
            x = max(min(x, m), 0)
            y = max(min(y, n), 0)
            return answer[x][y]

        ans = [[0] * n for _ in range(m)]
        for i in range(m):
            for j in range(n):
                ans[i][j] = get(i + K + 1, j + K + 1) - \
                            get(i - K, j + K + 1) - \
                            get(i + K + 1, j - K) + \
                            get(i - K, j - K)
        return ans


print(Solution().matrixBlockSum([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 1))

```



## [表示数字的最少运算符](https://leetcode-cn.com/problems/least-operators-to-express-number/)

![1602484381309](https://raw.githubusercontent.com/fadeawaylove/article-images/master/1602484381309.png)

代码实现：

```python
from functools import lru_cache

class Solution:
    def leastOpsExpressTarget(self, x: int, target: int) -> int:
        cost = list(range(40))
        cost[0] = 2
        
        @lru_cache(None)
        def dp(i, target):
            # i表示是x的几次幂，target是当前要得到的目标数
            if target == 0:
                return 0
            if target == 1:
                return cost[i]
            if i >= 39: 
                return float('inf')
            t, r = divmod(target, x)
            return min(r*cost[i]+dp(i+1, t), (x-r)*cost[i]+dp(i+1, t+1))

        return dp(0, target) - 1
```

## [环绕字符串中唯一的子字符串](https://leetcode-cn.com/problems/unique-substrings-in-wraparound-string/)

![1602489445540](https://raw.githubusercontent.com/fadeawaylove/article-images/master/1602489445540.png)

代码实现：

```python
# 使用hashmap
import collections

class Solution:
    def findSubstringInWraproundString(self, p: str) -> int:
        p = "^" + p
        # len_mapper为以当前字符结尾的最长子串的长度
        len_mapper = collections.defaultdict(lambda:0)
        w = 1
        for i in range(1, len(p)):
            if ord(p[i]) - ord(p[i-1]) in (1, -25):
                w += 1
            else:
                w = 1
            len_mapper[p[i]] = max(len_mapper[p[i]], w)
        # print(dict(len_mapper))
        return sum(len_mapper.values())
```

## [只有两个键的键盘](https://leetcode-cn.com/problems/2-keys-keyboard/)

![1602501508912](https://raw.githubusercontent.com/fadeawaylove/article-images/master/1602501508912.png)

思路：

> 将所有操作分成以 copy 为首的多组，形如 (copy, paste, ..., paste)，再使用 C 代表 copy，P 代表 paste。例如操作 `CPPCPPPPCP` 可以分为` [CPP][CPPPP][CP]` 三组。
>
> 假设每组的长度为 g_1, g_2, ...。完成第一组操作后，字符串有 g_1 个 A，完成第二组操作后字符串有 g_1 * g_2 个 A。当完成所有操作时，共有 g_1 * g_2 * ... * g_n 个 'A'。
>
> 我们最终想要 N = g_1 * g_2 * ... * g_n 个 A。如果 g_i 是合数，存在 g_i = p * q，那么这组操作可以分解为两组，第一组包含 1 个 C 和 p-1 个 P，第二组包含 1 个 C 和 q-1 个 P。
>
> 现在证明这种分割方式使用的操作最少。原本需要 $pq$ 步操作，分解后需要 $p+q$ 步。因为 $p+q <= pq$，等价于 $1 <= (p-1)(q-1)$，当 $p >= 2$ 且 $q >= 2$ 时上式永远成立。

代码：

```python
class Solution:

    def minSteps(self, n: int) -> int:
        i = 2
        res = 0
        # 进行质因数分解
        while n > 1:
            while n % i == 0:
                n //= i
                res += i
            i += 1
        return res
```





