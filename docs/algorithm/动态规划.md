
> 动态规划（英语：Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。  
> 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。   
> 动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。   
> 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。

方法总结：使用状态转移方程，描述中间状态之间的关系，即描述前一个小结果和后一个小结果之间的关系，依据这个关系链依次推导，可以得到最终结果。

适用情形：中间状态（结果）依赖于前一次的状态（结果）

## [三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

![三角形最小路径和题干](https://raw.githubusercontent.com/fadeawaylove/article-images/master/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C.png)

### 方法1：动态规划
解题思路：
> 使用动态规划关键还是找到状态转移方程，用$f(i,j)$表示三角形中第i行第j列元素的最短路径和，则可以得到状态转移方程：  
> $$
>f(i,j)=min(f(i-1, j), f(i-1, j-1)) + triangle[i][j]
>$$
> 意思就是：$当前元素的最短路径和=相邻上层元素的最短路径中的较小值+当前位置元素的值$
>（注意边界条件：元素为当前层第一个或者最后一个的时候，相邻的上层元素可以唯一确定）

代码如下：

```python
from typing import List


class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)  # 数组的长度（三角形的高度）
        f = [[0] * n for _ in range(n)]  # 保存每一层的结果，到当前层当前元素的最小路径
        f[0][0] = triangle[0][0]  # 第一层，第一个元素的结果就是三角形顶的值

        # 遍历获取每一层的结果
        for i in range(1, n):
            # 当前是第i行，从第二行（i=1表示第二行）开始
            # 这是边界条件，每一行的第一个元素只能由上一行的第一个元素获得
            f[i][0] = f[i - 1][0] + triangle[i][0]
            for j in range(1, i):
                # 第(i,j)个元素的结果，等于(i-1,j-1)和(i-1, j)中的较小值 加上 (i,j)处原本的值
                f[i][j] = min(f[i - 1][j], f[i - 1][j - 1]) + triangle[i][j]
            # 这是边界条件，每一行的第最后一个元素只能由上一行的最后一个元素获得
            f[i][i] = f[i - 1][i - 1] + triangle[i][i]
        return min(f[n - 1])


print(Solution().minimumTotal([
    [2],
    [3, 4],
    [6, 5, 7],
    [4, 1, 8, 3]
]))

```

### 方法2：动态规划+空间优化
解题思路：
> 方法1中我们使用了大小为$n*n$的矩阵来保存状态，是否可以使用更少的空间呢？用大小为$n$一维数组可以吗？
> 答案是可以的。   
> 如果每一层求解的时候从后往前计算，是不是就可以呢？考虑每一行最后一个元素的动态转移方程：$f(i,j)=min(f(i-1,j-1))+triangle[i][j]$，
>可以看到此时往保存状态的数组中第$j$个元素写入状态并不会改变之前已经得到的结果，因为此时状态数组中只有下标[0,j-1]的位置被占用了。


代码实现：
```python
from typing import List


class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)  # 数组的长度（三角形的高度）
        f = [0] * n  # 保存每一层的结果，到当前层当前元素的最小路径
        f[0] = triangle[0][0]  # 第一层，第一个元素的结果就是三角形顶的值

        # 遍历获取每一层的结果
        for i in range(1, n):
            f[i] = f[i-1] + triangle[i][i]  # 边界条件，f[i]是最后一个元素
            for j in range(i-1, 0, -1):
                # 第(i,j)个元素的结果，等于(i-1,j-1)和(i-1, j)中的较小值 加上 (i,j)处原本的值
                f[j] = min(f[j-1], f[j]) + triangle[i][j]
            # 这是边界条件，每一行的第最后一个元素只能由上一行的最后一个元素获得
            f[0] = f[0] + triangle[i][0]
        return min(f)


print(Solution().minimumTotal([
    [2],
    [3, 4],
    [6, 5, 7],
    [4, 1, 8, 3]
]))
```

## [计算各个位数不同的数字个数](https://leetcode-cn.com/problems/count-numbers-with-unique-digits/)

![](https://raw.githubusercontent.com/fadeawaylove/article-images/master/%E8%AE%A1%E7%AE%97%E5%90%84%E4%B8%AA%E4%BD%8D%E6%95%B0%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E5%AD%97%E4%B8%AA%E6%95%B0.png)

解题思路:
> 可以依次写出前几个的结果,看是否能得出转移方程:  
> $dp[0]=1$         
> $dp[1]=dp[0]+9$       
> $dp[2]=dp[1]+9*9$     
> $dp[3]=dp[2]+9*9*8$   
> 根据上面的式子,可以归纳出动态转移方程:
> $$
> \tag{n>=2}
> dp[n]=dp[n-1]+9*\prod_{i=0}^{n-2} {9-i} 
> $$
> 当然要注意n的取值范围.

代码实现:
```python
class Solution:
    def countNumbersWithUniqueDigits(self, n: int) -> int:
        dp = [0] * (n + 1)
        dp[0] = 1
        for i in range(1, n + 1):
            temp = 9
            for m in range(i - 1):
                temp *= 9 - m
            dp[i] = dp[i - 1] + temp
        return dp[-1]


print(Solution().countNumbersWithUniqueDigits(3))

```



## [整数拆分](https://leetcode-cn.com/problems/integer-break/)



![1600937575567](D:\用户目录\我的图片\1600937575567.png)

### 方法1：动态规划

解题思路：

> 设$dp[i]$为将正整数$i$拆分为至少两个正整数的和时的最大乘积，那么我们可以得到状态转移方程：
>
> $dp[i]=max(dp[i-j] \times j, (i-j) \times j)$，$(0<j<i)$
>
> 方程的含义就是，要求解$i$的最大乘积，可以将$i$拆分成两部分$j$和$i-j$,那么此时$dp[i]$就是$dp[i-j]\times j$和$(i-j)*j$中的较大值，其中$j$的取值范围为$(0,i)$

代码实现：

```python
class Solution:
    def integerBreak(self, n: int) -> int:
        dp = [0] * (n+1)
        for i in range(2, n+1):
            for j in range(1,i):
                dp[i] = max(dp[i],dp[i-j]*j, j*(i-j))
        return dp[-1]
```



### 方法2：动态规划优化

解题思路:

>方法1中$j$的范围为$(0,i)$,有没有办法缩小$j$的范围吗?
>
>我们知道,等分的时候乘积会是最大的,假设$n=a\times x$,$a$是分成的份数,那么我们要求的$y=x^{\frac n x}$的最大值,其实就是求$y=x^{\frac 1 x}$的最大值,根据数学的求导可以得出此时$x$应该为$e$($e\approx 2.7$),因为$x$为正整数,所以$x$可以为2或者3,落实到优化,$j$的取值范围可以只考虑2和3的情况.

代码实现:

```python
class Solution:
    def integerBreak(self, n: int) -> int:
        if n < 4:
            return n-1

        dp = [0] * (n+1)
        dp[2] = 1
        for i in range(2, n+1):
            dp[i] = max(dp[i-2]*2, 2*(i-2),dp[i-3]*3,3*(i-3))
        return dp[-1]
```

