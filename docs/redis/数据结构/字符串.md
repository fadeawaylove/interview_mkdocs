## 1.概念

Redis字符串实际上是简单动态字符串（simple dynamic string, SDS），Redis使用SDS而不是C语言的字符串（以空字符结尾的字符数组）来实现修改的动态字符串，C字符串是作为Redis字符串的字面量用在一些无需对字符串进行改变的地方，比如打印日志。简单来说Redis自己实现了一个SDS结构体，作为Redis字符串。

## 2. SDS介绍

Redis6.0源码地址：[https://github.com/redis/redis/tree/6.0](https://github.com/redis/redis/tree/6.0)

### 2.1 SDS结构

查看源码可以发现sds的定义`typedef char *sds;`，实际上sds定义的就是一个`char`类型，真正实现SDS的其实是结构体sds头`sdshdr`。

`src\sds.h`：

```c++
/* Note: sdshdr5 is never used, we just access the flags byte directly.
 * However is here to document the layout of type 5 SDS strings. */
struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len; /* used */
    uint8_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len; /* used */
    uint16_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len; /* used */
    uint32_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len; /* used */
    uint64_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
```

sdshdr5结构体：

- `flags`：大小1个字节，低3位表示header的类型，高5位表示字符串的长度
- `buf`：字节数组，保存字符串

除开sdshdr5，SDS结构体:

- `len` ：已经使用的空间（字节）长度，也就是字符串的长度
- `alloc` ：字符串的最大容量
- `flags` ：大小1个字节，低3位表示header的类型，高5位未使用
- `buf` ：字节数组，保存字符串

### 2.2 SDS与C字符串的区别

C语言中使用长度为$N+1$的字符数组来表示长度为$N$的字符串，并且字符数组的最后一个元素总是空字符"\o"。

![1602745027349](https://raw.githubusercontent.com/fadeawaylove/article-images/master/1602745027349.png)

C语言这种简单的字符串表示方式不能满足Redis对字符串在安全性、效率已经功能方面的要求。

#### 2.2.1 获取字符串的长度

C字符串需要遍历一遍，时间复杂度为$O(N)$:

![1602745250273](https://raw.githubusercontent.com/fadeawaylove/article-images/master/1602745250273.png)

和C字符串不同，SDS中的len属性，可以直接获得字符串长度，时间复杂度降为$O(1)$：

![1602746182629](https://raw.githubusercontent.com/fadeawaylove/article-images/master/1602746182629.png)



#### 2.2.2 缓冲区溢出

C字符串不记录自身长度，使用`<string.h>/strcat`函数将`src`字符串中的内容拼接到`dest`字符串的末尾：

```c
char *strcat(char *dest, const char *src)
```

如果执行`strcat`函数的时候没有预先为`dest`分配足够多的内存空间，就会产生缓冲区溢出。

与C字符串不同，Redis使用`sds.c/sdscat`函数进行字符串拼接时，如果`dest`空间不够，就会使用函数`sdsMakeRoomFor`扩容空间，避免了出现缓冲区溢出的情况（注意此时扩容空间时，并不是分配仅够扩容后字符串大小的空间，而是会冗余分配一些未使用的空间，可以想想这是为什么）。

#### 2.2.3 减少字符串修改带来的内存重新分配次数

C字符串修改时，都要进行一次内存重新分配操作：

- 如果时增长字符串，程序需要先通过内存重新分配来扩展底层数组空间大小，如果忘了这一步可能会产生缓存溢出。
- 如果是缩短字符串，程序在执行这个操作后，要通过内存重新分配来释放字符串不再使用的空间，如果忘了那就会产生内存泄漏。

因为内存分配涉及复杂的算法，还可能需要执行系统调用，所以它通常都是一个比较耗时的操作。在一般的程序中如果修改字符串的场景不太常见，那么每次修改内存都重新分配是可以接受的。但是Redis作为数据库，对性能要求很高，如果频繁的进行内存重新分配的系统调用，势必会影响性能。

为了避免C字符串的这种缺陷，SDS通过未使用空间解除了**字符串长度和底层字符数组长度**之间的关联，也就是数，`sdshdr`中的`len`和`alloc`并不一定相等。主要表现为两种策略：

##### a) 空间预分配

用于优化SDS字符串的增长操作：当SDS的API对一个SDS进行修改并且需要对SDS的空间进行扩展的时候，程序不仅会为SDS分配修改所必须的空间，还会为SDS分配额外的未使用空间，分配策略如下：

- 如果对SDS修改后，字符串长度小于1MB（即len属性小于1MB），那么程序将分配和len属性同样大小的未使用空间。
- 如果对SDS修改后，字符串长度大于1MB，那么程序会分配1MB的未使用空间。

##### b) 惰性空间释放

用于优化SDS字符串的缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不会立即进行内存分配来回收多出来的字节，而是只更新len的值。

相关函数：

`src/sds.c`：

```c
/* Modify an sds string in-place to make it empty (zero length).
 * However all the existing buffer is not discarded but set as free space
 * so that next append operations will not require allocations up to the
 * number of bytes previously available. */
void sdsclear(sds s) {
    sdssetlen(s, 0);
    s[0] = '\0';
}
```

`src/sds.h`：

```c
static inline void sdssetlen(sds s, size_t newlen) {
    unsigned char flags = s[-1];
    switch(flags&SDS_TYPE_MASK) {
        case SDS_TYPE_5:
            {
                unsigned char *fp = ((unsigned char*)s)-1;
                *fp = SDS_TYPE_5 | (newlen << SDS_TYPE_BITS);
            }
            break;
        case SDS_TYPE_8:
            SDS_HDR(8,s)->len = newlen;
            break;
        case SDS_TYPE_16:
            SDS_HDR(16,s)->len = newlen;
            break;
        case SDS_TYPE_32:
            SDS_HDR(32,s)->len = newlen;
            break;
        case SDS_TYPE_64:
            SDS_HDR(64,s)->len = newlen;
            break;
    }
}
```

这样做的好处是，可以避免缩短字符串时候的内重新分配，并为后续可能的字符增长进行了优化（如果未使用空间足够，则不需要重新分配内存）

#### 2.2.4 二进制安全

C字符串中的字符必须符合某种编码（比如ASCII），并且除了末尾以外，字符串不能包含空字符，即将空字符作为字符串结束的标志，这种限制使得C字符串只能保存文本数据，而不能保存图片、音频、视频、压缩文件这样的二进制数据。比如有一个字符串"Redis Cluster"，C字符串就只能识别出其中"Redis"而忽略之后的"Cluster"。

![1602848489275](https://raw.githubusercontent.com/fadeawaylove/article-images/master/1602848489275.png)

相比之下，SDS的API都是以处理二进制的方式来处理SDS皴法在buf数组里面的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，被读取的时候就是什么样的，这也是我们把buf成为字节数组的原因，同样保存"Redis Cluster"，SDS就不会有问题，因为SDS使用len属性的值来判断字符串的结束。

#### 2.2.5 兼容部分C字符串函数

虽然SDS的API都是二进制安全的，但是它们一样遵循C字符串以空字符结尾的惯例，这样一来，SDS可以重用\<string.h\>中定义的函数。

#### 2.2.6 总结

C字符串和SDS之间的区别：

![1602849161396](https://raw.githubusercontent.com/fadeawaylove/article-images/master/1602849161396.png)

### 2.3 SDS API

todo.......

### 2.4  重点回顾

- Redis只会使用C字符串作为字面量，在大多数情况下，Redis使用SDS作为字符串表示。
- 比起C字符串，SDS具有以下优点：
  - $O(1)$时间复杂度获取字符串长度
  - 分配冗余空间，杜绝缓冲区溢出
  - 减少修改字符串长度时所需的内存重分配次数
  - 二进制安全
  - 兼容部分C字符串函数

## 3.部分源码解析

### 3.1 字符串的编码

三种：

- int
- embede
- raw



三种encoding方式

![1602846380371](https://raw.githubusercontent.com/fadeawaylove/article-images/master/1602846380371.png)

`set key value`的过程：

命令：

```shell
set axaaa_long_key_a_long_key_a_long_key_a_long_key_a_long_key_a_long_key_a_long_key_a_long_key_a_long_key test_value2_test_value2_test_value2_test_value2_test_value2_test_value2_test_value2_test_value2_test_value22sadasda
```



第二次：

![1602675158725](https://raw.githubusercontent.com/fadeawaylove/article-images/master/1602675158725.png)





![1602675177847](https://raw.githubusercontent.com/fadeawaylove/article-images/master/1602675177847.png)



![1602675199337](https://raw.githubusercontent.com/fadeawaylove/article-images/master/1602675199337.png)



![1602675255080](https://raw.githubusercontent.com/fadeawaylove/article-images/master/1602675255080.png)



![1602675282970](https://raw.githubusercontent.com/fadeawaylove/article-images/master/1602675282970.png)







测试2：

命令` set abcd hahaha`

set命令的入口为函数`src/t_string.c`中的`setCommand`：

跟踪到`setGenericCommand`可以查看到key和value的值如下

![1602676944613](https://raw.githubusercontent.com/fadeawaylove/article-images/master/1602676944613.png)



![1602676953699](https://raw.githubusercontent.com/fadeawaylove/article-images/master/1602676953699.png)

继续到`genericSetKey`：











注意：根据string长度的不同 `src/object.c`里面的`createStringObject`会走不同的分支，分别是`createEmbeddedStringObject`和`createRawStringObject`







![](https://raw.githubusercontent.com/fadeawaylove/article-images/master/644862-20201009155635119-1183719627.jpg)

