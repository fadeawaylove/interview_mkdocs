## Redis

### 数据持久化

#### RDB

服务器启动的时候，检测到RDB文件就自动载入（如果服务器开启了AOF，会优先使用AOF文件还原数据库状态）。

**命令：**`save`和`bgsave`，`save`会阻塞Redis服务器进程，`bgsave`子进程负责创建RDB文件。

**dirty计数器**：上一次执行`save`或者`bgsave`命令后，服务器对数据库状态进行多少次修改。

**lastsave属性：**服务上次执行保存操作的时间。

**文件结构：**![image-20210425162730897](https://gitee.com/fadeaway_dai/picgo_images/raw/master/img/image-20210425162730897.png)

- REDIS标明是RDB文件
- db_version表示RDB文件的版本号
- databases多个数据库已经对应的键值
- check_sum校验和，根据前面四个部分计算得出

**重点：**

![image-20210425170739107](https://gitee.com/fadeaway_dai/picgo_images/raw/master/img/image-20210425170739107.png)

#### AOF

与RDB保存数据库中的键值对来记录数据库对应状态不同，AOF是通过保存Redis服务器执行的写命令来记录数据库状态。

**文件写入：**

1. 命令追加：客户端发送写命令->服务端执行写命令->将协议内容追加到aof_buf缓冲区末尾。
2. 文件写入：
   ![image-20210425164057124](https://gitee.com/fadeaway_dai/picgo_images/raw/master/img/image-20210425164057124.png)
3. 文件同步（可以理解为保存）：
   现代操作系统中，一般调用了write后数据不会立马写入，而是先保存在内存缓冲区里面，等内容到了一定大小或者时间超过指定时限后，才真正将缓冲区的数据写到磁盘上。

**文件载入：**

因为AOF文件包含了重建数据库状态需要的所有写命令，所以服务器只需要读入并重新执行一遍就行了（fake client）。

**AOF重写：**

AOF文件越来越大，影响Redis服务器、宿主机，恢复时间边长。AOF重写，用不带冗余命令的新AOF文件代替（原子操作）老的AOF文件。

读取现有的键值对，然后用一个命令去代替原先的多个命令，将当前键值对记录下来。

重写期间服务器进程新处理的命令请求改变数据库状态，使用aof_rewrite_buf：

![image-20210425170353269](https://gitee.com/fadeaway_dai/picgo_images/raw/master/img/image-20210425170353269.png)

子进程重写完毕后，服务器进程将AOF重写缓冲区的内容写到新的AOF文件中。

**重点：**

![image-20210425170716227](https://gitee.com/fadeaway_dai/picgo_images/raw/master/img/image-20210425170716227.png)

#### 混合持久化

还是通过bgrewriteaof，不同的是先按照rdb格式对数据库状态进行保存，再将aof_rewrite_buf写道AOF文件中。





## 参考

- [几率大的Redis面试题（含答案）](https://blog.csdn.net/Butterfly_resting/article/details/89668661)
- [天下无难试之Redis面试刁难大全 (qq.com)](https://mp.weixin.qq.com/s/-y1zvqWEJ3Tt4h39Z0WBJg)

